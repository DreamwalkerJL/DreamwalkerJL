/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import {
  AdaptiveEvents,
  Box,
  Cylinder,
  Lightformer,
  MeshReflectorMaterial,
  Plane,
  Text,
  useAnimations,
  useBVH,
  useGLTF,
  useHelper,
  useMatcapTexture,
} from '@react-three/drei';
import { useFrame, useLoader } from '@react-three/fiber';
import { Selection, Select } from '@react-three/postprocessing';
import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

export function Char({ choicePos, props }) {
  const group = useRef(); // for animation
  const groupRef = useRef(); // for rotation
  const meshRef = useRef(); // NOTHING YET
  const { nodes, animations } = useGLTF('/Char3Ani.glb');
  const { actions, ref, names } = useAnimations(animations, group);
  const [index, indexSet] = useState(0);
  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    actions[names[index]].reset().fadeIn(.5).play(); // .fadeIn(0.5)
    // In the clean-up phase, fade it out
    return () => actions[names[index]] // .fadeOut(0.5)
  }, [index, actions, names]);


  const [matcap1] = useMatcapTexture('6E5137_E8CA90_271912_B99C74');
  const [matcap2] = useMatcapTexture('161B1F_C7E0EC_90A5B3_7B8C9B');
  const [matcap3] = useMatcapTexture('0A0A0A_A9A9A9_525252_747474');


 useFrame(()=> {
  if(choicePos === 1 && hovered === true) {
    indexSet(2)
  } else {
    indexSet(1)
  }
 })

  function Podium() {
    return (
      <group name="middle" scale={1.2}>
        <Cylinder
          args={[1, 0.8, 0.25, 30]}
          rotation={[Math.PI, 0, 0]}
          position={[0, -0.4, 0]}
        >
          {/* <MeshReflectorMaterial
            color="#ffffff"
            blur={[400, 100]}
            resolution={1024}
            mixBlur={1}
            opacity={2}
            depthScale={1.1}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.25}
            roughness={1}
          /> */}
           <meshMatcapMaterial matcap={matcap3}/>
        </Cylinder>
        <Cylinder
          args={[1, 0.56, 0.27, 30]}
          rotation={[Math.PI, 0, 0]}
          position={[0, -0.4, 0]}
        >
          {/* <MeshReflectorMaterial
            color='#828282'
            blur={[400, 100]}
            resolution={1024}
            mixBlur={1}
            opacity={2}
            depthScale={1.1}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.25}
            roughness={1}
          /> */}

          <meshMatcapMaterial matcap={matcap3}/>
        </Cylinder>
        <Lightformer
          color={'#ffe0bd'}
          form="circle"
          scale={[0.8, 0.8]}
          rotation={[Math.PI * -0.5, 0, 0]}
          position={[0, -0.27, 0]}
          intensity={1.25}
          
        />
      </group>
    );
  }

  //Roation
  const vec1 = new THREE.Vector3(0, 0, 0);
  const vec2 = new THREE.Vector3(-3.75, 0, -3);
  const vec3 = new THREE.Vector3(4, 0, -3);
  useFrame((delta, time) => {
    if (choicePos === 1) {
      return groupRef.current.position.lerp(vec1, time * 2);
    } else if (choicePos === 2) {
      return groupRef.current.position.lerp(vec2, time * 2);
    } else if (choicePos === 3) {
      return groupRef.current.position.lerp(vec3, time * 2);
    } else {
      console.log('error');
    }
  });
  const matCapRef= useRef()


  const [hovered, hoveredSet] = useState(null);


  function hoveredColor() {
    return 
  }

  const [colorState, colorStateSet]= useState(200)

  useEffect(()=> {
    if(hovered && colorState <255) {
      colorStateSet(prev => prev + 1)
    } else if (hovered == false && colorState >200){
      colorStateSet(prev => prev - 1)
    }
  }, [hovered, colorState])

  return (
    <group ref={groupRef}>
      
      <Plane onPointerOver={()=> hoveredSet(true)}  onPointerOut={()=> hoveredSet(false)}  position={[0, 0.925, 1]} args={[1.2, 2.4]}>
        <meshBasicMaterial transparent opacity={0} />
      </Plane>
      <group ref={group} {...props} dispose={null} position={[0, -0.28, 0]} scale={1.4}>
        <group scale={0.01}>
          <group name="Armature" rotation={[Math.PI / 2, 0, 0]}>
            <group>
              <primitive object={nodes.mixamorigHips} />
            </group>
            <group>
              <skinnedMesh
                name="Ch44"
                geometry={nodes.Ch44.geometry}
                skeleton={nodes.Ch44.skeleton}
                // onPointerOver={() => console.log('hi')}
                // onPointerOut={() => console.log('hi')}

                ref={meshRef}
                rotation={[-Math.PI * 0.5, 0, 0]}
                position={[0, 0, 0]}
              >
                {/* <meshMatcapMaterial matcap={matcap1} color={`rgb(255, ${colorState}, ${colorState})`} opacity={1} transparent ref={matCapRef}/> */}
                <meshMatcapMaterial matcap={matcap1} color={`rgb(${colorState},${colorState},${colorState})`} opacity={1} transparent ref={matCapRef}/>
              </skinnedMesh>
            </group>
          </group>
        </group>
        {/* <Box onClick={() => setIndex((index + 1) % names.length)} /> */}
      </group>
      <Podium />

      <Text
        font={'PermanentMarker.ttf'}
        fontSize={0.4}
        position={[0, -0.44, 1.5]}
        rotation={[Math.PI * -0.4, 0, 0]}
        color={'#ffe0bd'}
      >
        3D
      </Text>
    </group>
  );
}

useGLTF.preload('/Char3Ani.glb');
